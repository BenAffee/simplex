#include "mainwindow.h"
#include "ui_mainwindow.h"
//*************************************************************************************************************
//*************************************************************************************************************
//*************************************************************************************************************
//*************************************************************************************************************
//----------------Методы для действий симплекс метода-----------------------------------------------------------
//*************************************************************************************************************
//*************************************************************************************************************
//*************************************************************************************************************
//*************************************************************************************************************

//*************************************************************************************************************
//*************************************************************************************************************
//----------------Проверка на оптимальность--------------------------------------------------------------------
//*************************************************************************************************************
//*************************************************************************************************************

void MainWindow::checkOfOptimal(){
    //проверяем план на оптимальность
    //если среди коэффициентов целевой функции нет отрицательных элементов, то план оптимален

    //будем перебирать коэффициенты вектора r до тех пор,
    //пока не найдём отрицательный элемент. Если он найден,
    //то признак оптимальности установим в false


    //устанавливаем признак оптимальности в истину
    optimal = true;

    //tmpVector = simplexTable.last();
    for(i=0; i < r.size(); i++)
        if (r[i] < 0) optimal = false;

    if(optimal == true){
        ui->status->append("Найдено оптимальное решение!");
        msgBox.setText("Найдено оптимальное решение!");
        msgBox.exec();
        return;
    }

    ui->status->append("================================================");
    ui->status->append("Решение НЕ оптимально, продолжаем...");
    ui->status->append("Симплекс шаг: " + QString::number(globalSteps));
}

void MainWindow::permittedCol(){
    //выбираем разрешающий столбец
    //это максимальный по модулю отрицательный компонент вектора r
    minNum = -1;
    fMin = 0;
    for(i=0; i < r.size(); i++){
        if ((r[i] < 0) && (fabs(r[i]) > fMin)){
            fMin = r[i];
            minNum = i;
        }
    }
    if(minNum == -1){
        ui->status->append("Ошибка! Не определён максимальный по модулю отрицательный компонент вектора r");
        return;
    }

    //устанавливаем разрешающий столбец
    permCol = minNum;
}

void MainWindow::permittedRow(){
    //рассчитаем столбец значений b=h/(элементы разрешающего столбца)
    for(i=0; i < simplexTable.size()-1; i++){
        tmpVector = simplexTable[i];
        if(tmpVector[permCol] > 0)
            colB[i] = tmpVector.last() / tmpVector[permCol];
        else
            colB[i] = -1;

        //сразу запишем в модель...
        modIndex = simplexTabModel->index(i, maxCol-1);
        simplexTabModel->setData(modIndex,colB[i]);
    }
    //qDebug()<<"2";
    //найдём минимальный положительный элемент в столбце b
    //для этого сначала найдём первый положительный элемент в столбце,
    //а затем сравним его с остальными
    i=0;
    while(colB[i]<0){
        i++;
    }
    fMin=colB[i];//сюда запишется первый положительный или нулевой элемент
    minNum = i;//...а сюда его номер
    for(i=minNum; i < colB.size(); i++){
        if ((colB[i] >= 0) && (colB[i] < fMin)){
            fMin = colB[i];
            minNum = i;
        }
    }

    //установим разрешающую строку
    permRow = minNum;
}

void MainWindow::simplexTransformation(){
    //начинаем симплекс-преобразования
    //реплицируем симплекс-таблицу
    //(из одной будем брать исходные данные, а во вторую подставлять результаты)
    simplexTableRepl = simplexTable;

    //элементы не разрешающего столбца и строки пересчитаем по правилу прямоугольника
    for(i=0; i < simplexTable.size(); i++){
        if (i != permRow){
            for(j=0; j < maxCol-1; j++){
                //если текущий элемент не относится к разрешающей строке или столбцу,
                //то пересчитываем, иначе просто пропускаем
                if(j != permCol)
                    simplexTableRepl[i][j] = simplexTable[i][j] - (simplexTable[permRow][j] * simplexTable[i][permCol] / permItem);
            }
        }

    }

    //разрешающий элемент превращаем в 1
    simplexTableRepl[permRow][permCol] = 1;

    //элементы разрешающей строки делим на разрешающий элемент
    for(i=0; i < maxCol-1; i++)
        if (i != permCol) simplexTableRepl[permRow][i] = simplexTable[permRow][i] / permItem;

    //элементы разрешающего столбца превращаем в 0
    for(i=0; i < simplexTableRepl.size(); i++)
        if (i != permRow) simplexTableRepl[i][permCol] = 0;

    //последний элемент целевой функции ставим в ноль (он недолжен пересчитываться)
    //simplexTable[simplexTable.size()-1][maxCol-2]=0;


    //переписываем реплику симплекс таблицы в исходную
    simplexTable = simplexTableRepl;

    //записываем вектор r
    tmpVector = simplexTable.last();
    r.clear();
    for(i=0; i<maxColStart; i++)
        r.append(tmpVector[i]);

    //отражаем вектор r в статус-бокс
    tmpString.clear();
    foreach(i,r)
        tmpString.append(QString::number(i) + ",");
    ui->status->append("Вектор r: " + tmpString);
}

//симплекс-преобразования без ввода вывода

void MainWindow::simplexTransformationNoOutput(){
    //начинаем симплекс-преобразования
    //реплицируем симплекс-таблицу
    //(из одной будем брать исходные данные, а во вторую подставлять результаты)
    simplexTableRepl = simplexTable;

    //элементы не разрешающего столбца и строки пересчитаем по правилу прямоугольника
    for(i=0; i < simplexTable.size(); i++){
        if (i != permRow){
            for(j=0; j < maxCol-1; j++){
                //если текущий элемент не относится к разрешающей строке или столбцу,
                //то пересчитываем, иначе просто пропускаем
                if(j != permCol)
                    simplexTableRepl[i][j] = simplexTable[i][j] - (simplexTable[permRow][j] * simplexTable[i][permCol] / permItem);
            }
        }

    }

    //разрешающий элемент превращаем в 1
    simplexTableRepl[permRow][permCol] = 1;

    //элементы разрешающей строки делим на разрешающий элемент
    for(i=0; i < maxCol-1; i++)
        if (i != permCol) simplexTableRepl[permRow][i] = simplexTable[permRow][i] / permItem;

    //элементы разрешающего столбца превращаем в 0
    for(i=0; i < simplexTableRepl.size(); i++)
        if (i != permRow) simplexTableRepl[i][permCol] = 0;

    //переписываем реплику симплекс таблицы в исходную
    simplexTable = simplexTableRepl;

    //записываем вектор r
    tmpVector = simplexTable.last();
    r.clear();
    for(i=0; i<maxColStart; i++)
        r.append(tmpVector[i]);

}

void MainWindow::checkOfOptimalNoOutput(){
    //проверяем план на оптимальность
    //если среди коэффициентов целевой функции нет отрицательных элементов, то план оптимален

    //будем перебирать коэффициенты вектора r до тех пор,
    //пока не найдём отрицательный элемент. Если он найден,
    //то признак оптимальности установим в false


    //устанавливаем признак оптимальности в истину
    optimal = true;

    //tmpVector = simplexTable.last();
    for(i=0; i < r.size(); i++)
        if (r[i] < 0) optimal = false;



}

void MainWindow::permittedRowNoOutput(){
    //рассчитаем столбец значений b=h/(элементы разрешающего столбца)
    for(i=0; i < simplexTable.size()-1; i++){
        tmpVector = simplexTable[i];
        if(tmpVector[permCol] > 0)
            colB[i] = tmpVector.last() / tmpVector[permCol];
        else
            colB[i] = -1;
    }

    //найдём минимальный положительный элемент в столбце b
    //для этого сначала найдём первый положительный элемент в столбце,
    //а затем сравним его с остальными
    i=0;
    while(colB[i]<0){
        i++;
    }
    fMin=colB[i];//сюда запишется первый положительный или нулевой элемент
    minNum = i;//...а сюда его номер
    for(i=minNum; i < colB.size(); i++){
        if ((colB[i] >= 0) && (colB[i] < fMin)){
            fMin = colB[i];
            minNum = i;
        }
    }

    //установим разрешающую строку
    permRow = minNum;
}
